# 03장: 리액트 훅 깊게 살펴보기

리액트를 이루는 핵심 요소들을 깊게 살펴보고, 리액트의 렌더링 과정을 이해하는 장입니다.


<br>

## 3.1 리액트 훅 깊게 살펴보기

리액트 훅은 함수 컴포넌트에서 상태 관리와 라이프사이클 메소드를 사용할 수 있게 해주는 기능입니다. 각 훅은 고유한 기능을 제공하며, 컴포넌트의 복잡성을 줄이고 코드의 재사용성을 높이는 데 도움이 됩니다. 아래는 주요 리액트 훅들에 대한 상세 설명, 예제, 그리고 각 훅의 핵심 개념과 문법입니다.

### 3.1.1 useState

`useState`는 함수 컴포넌트에서 상태를 추가하는 훅입니다. 초기 상태를 인자로 받아 현재 상태 값과 상태를 갱신할 수 있는 함수를 반환합니다.

- **Syntax:**
  ```jsx
  const [state, setState] = useState(initialState);
  ```

- **Key Concepts:**
  - **상태 초기화**: 컴포넌트가 처음 렌더링될 때 상태의 초기값을 설정합니다.
  - **상태 값 반환**: 현재 상태 값을 읽을 수 있습니다.
  - **상태 갱신 함수 반환**: 상태를 업데이트할 수 있는 함수를 제공합니다. 이 함수는 상태가 업데이트되면 컴포넌트를 다시 렌더링합니다.

```jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

### useState 훅의 지연 초기화 (Lazy Initialization)

`useState` 훅의 지연 초기화(lazy initialization)는 상태의 초기값을 계산하는 비용이 클 때 유용합니다. 보통 상태를 초기화할 때, 초기값을 직접 인자로 전달합니다. 하지만 초기값을 계산하는 로직이 복잡하거나 시간이 많이 걸리는 경우, 함수 형태로 초기값을 전달하여 필요한 시점에만 계산되도록 할 수 있습니다.

- **지연 초기화의 문법:**
  ```jsx
  const [state, setState] = useState(() => initialStateFunction());
  ```

- **Key Concepts:**
  - **지연 초기화의 필요성**: 초기 상태를 계산하는 로직이 복잡하거나, 네트워크 요청처럼 비용이 큰 작업일 때 유용합니다.
  - **초기값 계산 지연**: `useState`에 함수를 전달하면, 컴포넌트가 처음 렌더링될 때만 해당 함수가 실행되어 초기값을 계산합니다. 이후에는 이 함수가 다시 실행되지 않습니다.
  - **성능 최적화**: 지연 초기화를 통해 불필요한 계산을 피하고 성능을 최적화할 수 있습니다.

- **예제 코드:**
  ```jsx
  import React, { useState } from 'react';

  // 복잡한 초기값 계산 함수
  const computeInitialValue = () => {
    console.log('초기값 계산 중...');
    // 복잡한 로직 또는 비용이 큰 작업 수행
    return 10;
  };

  function Counter() {
    // 지연 초기화를 사용하여 초기값 설정
    const [count, setCount] = useState(() => computeInitialValue());

    return (
      <div>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>Increment</button>
      </div>
    );
  }

  export default Counter;
  ```

- **예제 설명:**
  - `computeInitialValue` 함수는 초기값을 계산하는 복잡한 로직을 포함하고 있습니다.
  - `useState` 훅을 사용할 때, 함수 형태로 초기값을 전달하여 컴포넌트가 처음 렌더링될 때만 `computeInitialValue` 함수가 실행됩니다.
  - 이후 상태가 변경될 때는 이 함수가 다시 실행되지 않습니다. 이는 초기 렌더링 시에만 초기값을 계산하는 비용을 지불하게 되므로 성능에 긍정적인 영향을 줍니다.

- **고려 사항:**
  - 초기값 계산이 매우 단순하거나 비용이 크지 않은 경우, 굳이 지연 초기화를 사용할 필요는 없습니다.
  - 지연 초기화를 통해 상태 초기화 로직을 명확히 하고, 불필요한 계산을 피함으로써 코드의 효율성을 높일 수 있습니다.


### 3.1.2 useEffect

`useEffect`는 함수 컴포넌트에서 부수 효과(side effects)를 수행하기 위한 훅입니다. 데이터 가져오기, 구독 설정, DOM 조작 등 다양한 작업을 처리할 수 있으며, 컴포넌트가 렌더링될 때마다 실행됩니다. `useEffect`는 클래스 컴포넌트의 `componentDidMount`, `componentDidUpdate`, `componentWillUnmount` 메서드를 통합한 것과 같은 역할을 합니다.

#### Syntax
```jsx
useEffect(() => {
  // Effect code here (실행할 코드)
  return () => {
    // Cleanup code here (정리 코드, 선택 사항)
  };
}, [dependencies]); // 의존성 배열
```

- **Key Concepts:**
  - **부수 효과 수행**: `useEffect` 내에서 데이터 가져오기, 구독 설정, 수동 DOM 조작 등의 작업을 처리합니다. 부수 효과는 컴포넌트의 렌더링 이후에 발생합니다.
  - **의존성 배열 관리**: 의존성 배열에 명시된 값이 변경될 때만 `useEffect`가 다시 실행됩니다. 의존성 배열이 비어 있으면(`[]`), `useEffect`는 컴포넌트가 처음 마운트될 때 한 번만 실행됩니다.
  - **정리 함수 반환**: 부수 효과가 더 이상 필요하지 않거나 컴포넌트가 언마운트될 때 정리 작업을 수행하는 함수를 반환합니다. 이를 통해 메모리 누수 및 구독 해제 등을 관리할 수 있습니다.

#### Example
```jsx
import React, { useState, useEffect } from 'react';

function DataFetcher() {
  const [data, setData] = useState(null);

  useEffect(() => {
    // 데이터 가져오기
    fetch('https://api.example.com/data')
      .then(response => response.json())
      .then(data => setData(data));

    // 정리 함수
    return () => {
      console.log('Cleanup');
    };
  }, []); // 빈 배열: 마운트 시 한 번 실행

  return (
    <div>
      <p>Data: {JSON.stringify(data)}</p>
    </div>
  );
}
```

**Example Explanation:**
- `useState`를 사용하여 `data`라는 상태를 생성하고, `setData`로 상태를 업데이트합니다.
- `useEffect`를 사용하여 컴포넌트가 마운트될 때 한 번 데이터를 가져옵니다. 의존성 배열을 빈 배열로 설정하여, 이 효과는 컴포넌트가 처음 렌더링될 때만 실행됩니다.
- `fetch`를 사용하여 API로부터 데이터를 가져오고, 가져온 데이터를 `setData`를 통해 상태에 저장합니다.
- `useEffect`의 반환 값으로 정리 함수를 제공하여, 컴포넌트가 언마운트될 때 콘솔 로그를 출력합니다. 이는 실제 사용 사례에서는 구독 해제, 타이머 정리 등으로 사용될 수 있습니다.

### 3.1.3 useMemo

`useMemo`는 성능 최적화를 위해 특정 연산의 결과를 메모이제이션하는 훅입니다. 의존성 배열이 변경될 때만 메모이제이션된 값을 재계산합니다.

- **Syntax:**
  ```jsx
  const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
  ```

- **Key Concepts:**
  - **값 메모이제이션**: 반복되는 연산의 결과를 캐시하여 성능을 최적화합니다.
  - **성능 최적화**: 의존성 배열의 값이 변경되지 않는 한, 이전에 계산된 값을 반환하여 불필요한 연산을 방지합니다.
  - **의존성 배열**: 어떤 값이 변경되었을 때만 메모이제이션된 값을 재계산하도록 제어합니다.

```jsx
import React, { useState, useMemo } from 'react';

function ExpensiveCalculationComponent({ number }) {
  const expensiveCalculation = (num) => {
    console.log('Calculating...');
    return num * 2;
  };

  const memoizedValue = useMemo(() => expensiveCalculation(number), [number]);

  return <div>Result: {memoizedValue}</div>;
}
```

### 3.1.4 useCallback

`useCallback`은 콜백 함수의 메모이제이션을 위해 사용되는 훅입니다. 주로 자식 컴포넌트에 전달되는 함수를 메모이제이션하여 불필요한 렌더링을 방지합니다.

- **Syntax:**
  ```jsx
  const memoizedCallback = useCallback(() => {
    doSomething(a, b);
  }, [a, b]);
  ```

- **Key Concepts:**
  - **함수 메모이제이션**: 콜백 함수를 메모이제이션하여 참조의 안정성을 보장합니다.
  - **불필요한 렌더링 방지**: 메모이제이션된 함수는 의존성 배열의 값이 변경되지 않는 한 동일한 함수 참조를 유지하여 자식 컴포넌트의 불필요한 렌더링을 방지합니다.
  - **의존성 배열**: 콜백 함수가 재생성되는 조건을 제어합니다.

```jsx
import React, { useState, useCallback } from 'react';

function Button({ onClick }) {
  return <button onClick={onClick}>Click me</button>;
}

function ParentComponent() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    setCount(count + 1);
  }, [count]);

  return (
    <div>
      <p>Count: {count}</p>
      <Button onClick={handleClick} />
    </div>
  );
}
```

### 3.1.5 useRef

`useRef`는 DOM 노드나 리액트 요소에 접근할 수 있는 참조 객체를 생성하는 훅입니다. 주로 직접 DOM 조작이 필요할 때 사용됩니다.

- **Syntax:**
  ```jsx
  const refContainer = useRef(initialValue);
  ```

- **Key Concepts:**
  - **참조 객체 생성**: DOM 요소나 컴포넌트 인스턴스에 접근할 수 있는 객체를 생성합니다.
  - **DOM 접근**: DOM 요소를 직접 제어하거나 조작할 수 있습니다.
  - **컴포넌트 상태와 무관한 값 저장**: 렌더링 사이에서도 값을 유지합니다.

```jsx
import React, { useRef } from 'react';

function TextInput() {
  const inputRef = useRef(null);

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}
```

### 3.1.6 useContext

`useContext`는 리액트 컨텍스트를 사용하여 전역 상태를 관리하는 훅입니다. 컨텍스트 객체를 인자로 받아 현재 컨텍스트 값을 반환합니다.

- **Syntax:**
  ```jsx
  const value = useContext(MyContext);
  ```

- **Key Concepts:**
  - **전역 상태 관리**: 컴포넌트 트리 전체에서 상태를 공유할 수 있습니다.
  - **컨텍스트 값 반환**: 현재 컨텍스트 값을 쉽게 접근할 수 있습니다.
  - **컨텍스트 객체 사용**: 여러 컴포넌트 간의 상태 공유를 가능하게 합니다.

```jsx
import React, { useContext, createContext } from 'react';

const ThemeContext = createContext('light');

function ThemedComponent() {
  const theme = useContext(ThemeContext);

  return <div>Current theme: {theme}</div>;
}
```

### 3.1.7 useReducer

`useReducer`는 복잡한 상태 로직을 관리하기 위한 훅입니다. 리듀서 함수와 초기 상태를 인자로 받아 현재 상태와 디스패치 함수를 반환합니다.

- **Syntax:**
  ```jsx
  const [state, dispatch] = useReducer(reducer, initialArg, init);
  ```

- **Key Concepts:**
  - **복잡한 상태 관리**: 상태 전환 로직이 복잡하거나 다단계인 경우 유용합니다.
  - **리듀서 함수**: 상태 전환 로직을 캡슐화한 함수입니다.
  - **디스패치 함수**: 액션 객체를 전달하여 상태를 업데이트합니다.

```jsx
import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <p>Count: {state.count}</p>
      <

button onClick={() => dispatch({ type: 'increment' })}>Increment</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>
    </div>
  );
}
```

### 3.1.8 useImperativeHandle

`useImperativeHandle`은 부모 컴포넌트가 자식 컴포넌트의 인스턴스 메서드에 접근할 수 있도록 하는 훅입니다. 주로 포워딩된 ref와 함께 사용됩니다.

- **Syntax:**
  ```jsx
  useImperativeHandle(ref, createHandle, [dependencies]);
  ```

- **Key Concepts:**
  - **인스턴스 메서드 접근**: 부모 컴포넌트가 자식 컴포넌트의 특정 메서드에 접근할 수 있습니다.
  - **ref 포워딩**: 부모 컴포넌트로부터 전달된 ref를 자식 컴포넌트로 전달합니다.
  - **사용자 정의 인스턴스 값**: ref 객체를 통해 노출할 값이나 메서드를 정의합니다.

```jsx
import React, { useRef, useImperativeHandle, forwardRef } from 'react';

const CustomInput = forwardRef((props, ref) => {
  const inputRef = useRef();

  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    },
  }));

  return <input ref={inputRef} type="text" />;
});

function ParentComponent() {
  const inputRef = useRef();

  return (
    <div>
      <CustomInput ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>Focus Input</button>
    </div>
  );
}
```

### 3.1.9 useLayoutEffect

`useLayoutEffect`는 브라우저가 레이아웃과 페인팅을 완료하기 전에 동기적으로 실행되는 훅입니다. 주로 DOM을 직접 조작해야 할 때 사용됩니다.

- **Syntax:**
  ```jsx
  useLayoutEffect(() => {
    // Effect code here
    return () => {
      // Cleanup code here (optional)
    };
  }, [dependencies]);
  ```

- **Key Concepts:**
  - **동기적 실행**: 브라우저가 화면을 그리기 전에 동기적으로 실행됩니다.
  - **DOM 조작**: DOM을 조작하거나 읽을 때 사용됩니다.
  - **레이아웃 후 페인팅 전 실행**: 렌더링 후 바로 실행되므로 시각적 조작에 적합합니다.

```jsx
import React, { useLayoutEffect, useRef } from 'react';

function LayoutEffectComponent() {
  const divRef = useRef(null);

  useLayoutEffect(() => {
    console.log('Layout Effect');
    divRef.current.style.backgroundColor = 'lightblue';
  }, []);

  return <div ref={divRef}>This div has a background color set by useLayoutEffect</div>;
}
```

### 3.1.10 useDebugValue

`useDebugValue`는 커스텀 훅을 디버깅할 때 유용한 훅입니다. 리액트 개발자 도구에서 훅의 값을 표시할 수 있습니다.

- **Syntax:**
  ```jsx
  useDebugValue(value);
  useDebugValue(value, formatFunction);
  ```

- **Key Concepts:**
  - **디버깅 지원**: 커스텀 훅의 상태를 쉽게 디버깅할 수 있습니다.
  - **커스텀 훅**: 사용자 정의 훅에 추가적인 디버깅 정보를 제공합니다.
  - **개발자 도구 통합**: 리액트 개발자 도구에 디버깅 정보를 표시합니다.

```jsx
import React, { useState, useDebugValue } from 'react';

function useCustomHook(initialValue) {
  const [value, setValue] = useState(initialValue);

  useDebugValue(value ? 'Value is set' : 'Value is not set');

  return [value, setValue];
}

function DebugValueComponent() {
  const [value, setValue] = useCustomHook('Hello');

  return (
    <div>
      <p>{value}</p>
      <button onClick={() => setValue('World')}>Change Value</button>
    </div>
  );
}
```

### 3.1.11 훅의 규칙

리액트 훅은 특정 규칙을 따라야 합니다. 훅은 컴포넌트의 최상위 레벨에서만 호출해야 하며, 반복문, 조건문, 중첩된 함수 내에서 호출해서는 안 됩니다. 또한, 훅은 리액트 함수 컴포넌트와 커스텀 훅에서만 호출할 수 있습니다.

- **Syntax:**
  ```text
  // 예시 구문은 없지만, 훅을 사용하는 위치와 방법을 설명합니다.
  ```

- **Key Concepts:**
  - **컴포넌트 최상위 레벨에서 호출**: 훅은 컴포넌트의 최상위에서만 호출해야 합니다. 이를 통해 훅이 항상 동일한 순서로 호출되도록 보장합니다.
  - **반복문, 조건문, 중첩 함수 내 호출 금지**: 훅은 반복문, 조건문, 또는 중첩된 함수 내에서 호출해서는 안 됩니다. 이를 통해 훅의 호출 순서를 유지하고, 상태 관리가 예측 가능하도록 합니다.
  - **함수 컴포넌트와 커스텀 훅에서만 호출 가능**: 훅은 함수 컴포넌트 또는 커스텀 훅 내에서만 호출할 수 있습니다. 클래스 컴포넌트에서는 사용할 수 없습니다.

---

**Q1:** 리액트 훅 중에서 `useEffect`와 `useLayoutEffect`의 차이점은 무엇인가요?

<details>
<summary>정답 보기</summary>
`useEffect`는 비동기적으로 실행되며, 브라우저가 화면을 업데이트한 후에 실행됩니다. 반면 `useLayoutEffect`는 동기적으로 실행되어 브라우저가 레이아웃과 페인팅을 완료하기 전에 실행됩니다. `useLayoutEffect`는 DOM을 즉시 조작해야 하는 경우에 유용합니다.
</details>

**Q2:** `useReducer` 훅을 사용하는 것이 `useState`보다 유리한 경우는 언제인가요?

<details>
<summary>정답 보기</summary>
`useReducer` 훅은 상태가 복잡하고 여러 하위 값으로 구성되거나, 상태 갱신 로직이 복잡한 경우에 유리합니다. 예를 들어, 여러 액션 타입을 처리해야 하거나 상태 전환이 복잡한 경우 `useReducer`를 사용하면 상태 관리가 더 간단하고 명확해질 수 있습니다.
</details>

**Q3:** `useCallback`과 `useMemo` 훅의 용도와 차이점은 무엇인가요?

<details>
<summary>정답 보기</summary>
 `useCallback`은 콜백 함수를 메모이제이션하여 불필요한 렌더링을 방지하는 데 사용됩니다. 주로 자식 컴포넌트에 전달되는 함수를 메모이제이션합니다. `useMemo`는 값의 메모이제이션을 위해 사용되며, 특정 계산의 결과를 캐싱하여 성능을 최적화합니다. 둘 다 성능 최적화를 위해 사용되지만, `useCallback`은 함수, `useMemo`는 값을 메모이제이션하는 데 차이가 있습니다.
</details>

**Q4:** 리액트 훅 중에서 `useEffect`와 `useLayoutEffect`의 차이점은 무엇인가요?

<details>
<summary>정답 보기</summary>
`useEffect`는 비동기적으로 실행되며, 브라우저가 화면을 업데이트한 후에 실행됩니다. 반면 `useLayoutEffect`는 동기적으로 실행되어 브라우저가 레이아웃과 페인팅을 완료하기 전에 실행됩니다. `useLayoutEffect`는 DOM을 즉시 조작해야 하는 경우에 유용합니다.
</details>

**Q5:** `useReducer` 훅을 사용하는 것이 `useState`보다 유리한 경우는 언제인가요?

<details>
<summary>정답 보기</summary>
`useReducer` 훅은 상태가 복잡하고 여러 하위 값으로 구성되거나, 상태 갱신 로직이 복잡한 경우에 유리합니다. 예를 들어, 여러 액션 타입을 처리해야 하거나 상태 전환이 복잡한 경우 `useReducer`를 사용하면 상태 관리가 더 간단하고 명확해질 수 있습니다.
</details>

**Q6:** `useCallback`과 `useMemo` 훅의 용도와 차이점은 무엇인가요?

<details>
<summary>정답 보기</summary>
`useCallback`은 콜백 함수를 메모이제이션하여 불필요한 렌더링을 방지하는 데 사용됩니다. 주로 자식 컴포넌트에 전달되는 함수를 메모이제이션합니다. `useMemo`는 값의 메모이제이션을 위해 사용되며, 특정 계산의 결과를 캐싱하여 성능을 최적화합니다. 둘 다 성능 최적화를 위해 사용되지만, `useCallback`은 함수, `useMemo`는 값을 메모이제이션하는 데 차이가 있습니다.
</details>


**Q7:** `useEffect`에서 의존성 배열을 빈 배열(`[]`)로 설정하면 어떤 일이 발생하나요?

**Q8:** `useEffect`의 정리 함수는 언제 호출되며, 어떤 용도로 사용되나요?

**Q9:** `useEffect`에서 상태 업데이트를 수행할 때 무한 루프를 방지하는 방법은 무엇인가요?

**Q10:** 지연 초기화를 사용하지 않고 `useState`에 직접 값을 전달했을 때의 단점은 무엇인가요?

**Q11:** 지연 초기화를 사용하는 것이 성능에 어떤 긍정적인 영향을 줄 수 있나요?

**Q12:** 지연 초기화를 사용할 때 주의해야 할 점은 무엇인가요?
---

