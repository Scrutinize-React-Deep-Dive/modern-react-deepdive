### 2.4.1 리액트의 렌더링이란?

리액트의 렌더링이란 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다.

=> DOM에 반영하는 것이 아니라 실제 돔에 어떤 것을 반영할 지를 계산하는 것.

### 2.4.2 리액트의 렌더링이 일어나는 이유

리액트에서 렌더링이 발생하는 시나리오를 알아보자.

1. 최초 렌더링 : 사용자가 처음 애플리케이션에 진입했을 경우에 리액트는 브라우저에 이 정보를 제공하기 위해 최초 렌더링을 수행한다.
2. 리렌더링 : 최초 렌더링 이후에 발생하는 모든 렌더링을 의미한다. 리렌더링이 발생하는 경우는 다음과 같다.
   - 클래스 컴포넌트의 setState가 실행되는 경우.
   - 클래스 컴포넌트의 forceUpdate가 실행되는 경우. 주의할 점은 forceUpdate는 개발자가 강제로 렌더링을 일으키는 것이기 때문에 shouldComponentUpdate 메서드를 무시한다.
   - 함수 컴포넌트의 useState()의 두 번째 배열 요소인 setter가 실행되는 경우
   - 함수 컴포넌트의 useReducer의 두 번째 배열 요소인 dispatch가 실행되는 경우
   - 함수 컴포넌트의 key props가 변경되는 경우
     - key 값은 current 트리와 workInProgress 트리 사이에서 어떠한 컴포넌트가 변경이 있었는데 구별하는데 사용된다.
   - 함수 컴포넌트의 props가 변경되는 경우
   - 부모 컴포넌트가 렌더링될 경우
     - 부모 컴포넌트가 렌더링되면 자식 컴포넌트는 반드시 렌더링된다.

### 2.4.3 리액트의 렌더링 프로세스

앞에서는 리액트 렌더링이 발생하는 시나리오를 알아봤다. 지금부터는 렌더링 과정을 알아보자.

렌더링 프로세스가 실행되면 리액트는 루트 컴포넌트부터 시작해서 모든 하위 컴포넌트를 순회하며 업데이트가 필요한 컴포넌트를 찾는다. 만약 여기서 업데이트가 필요하다고 판단되면 class에서는 render() 함수를 실행하고, 함수에서는 함수 컴포넌트 그 자체를 실행한다.

렌더링 프로세스는 모든 컴포넌트를 순회하면 렌더링 결과물을 수집한 다음, 리액트의 새로운 트리인 가상 DOM과 실제 DOM에 반영하기 위한 모든 변경 사항을 차례차례 수집한다.
이러한 과정을 리액트의 재조정이라고 한다. DOM에 반영할 변경 사항에 대한 자료 수집이 끝나면 동기 시퀀스로 DOM에 적용한다.

이러한 과정은 크게 렌더 단계와 커밋 단계로 나뉜다.

### 2.4.4 렌더와 커밋

렌더 단계는 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다. type, props, key를 기반으로 변경된 것이 아니라도 있으면 render나 return을 수행해서 workInProgress 트리를 만든다. 그리고 current 트리와 비교해서 변경된 것이 있는지 확인한다.

커밋 단계는 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 것으로 실제 브라우저 렌더링이 발생한다.

중요한 사실은 `리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니라는 사실`이다. 렌더링을 수행했으나 커밋 단계까지 갈 필요가 없다면, 즉 변경 사항을 계산했는데 아무런 변경 사항이 감지되지 안흔ㄴ다면 이 커밋 단계는 생략된다.

리액트 18에서는 동시성 렌더링이 도입되었다. 동시성 렌더링은 렌더링 중 렌더 단계가 비동기로 작동해 특정 렌더링의 우선순위를 낮추거나, 필요하다면 중단하거나 재시작하거나, 경우에 따라서느 포기할 수도 있다. 해당 작업은 리액트 스케줄러가 맡아서 수행한다.

## 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

리액트에서 제공하는 useMemo, useCallback 훅과 고차 컴포넌트인 memo는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해서 제공된다.

무조건 메모이제이션은 필요하다와 그렇지 않다는 논쟁은 꾸준히 이어져왔고, 각각의 주장을 살펴보자.

### 2.5.1 꼭 필요한 곳에서만 메모이제이션을 추가하자

메모이제이션도 어느 정도의 트레이드 오프가 있는 기법이라고 보는 것이 옳다. 이전 결과를 캐시로 저장하는 과정에서 메모리를 점유하게 된다. 또, 메모리에 저장한 결과를 찾아오는 과정도 시간이 소요된다.

실제로 리액트 공식 문서에서도 useMemo가 언제까지나 성능 최적화를 해줄 것이라 믿지 말라고 한다.

### 2.5.2 렌더링 과정이 비싸니 모조리 메모이제이션 하자

렌더링은 매우 비싼 작업이기 때문에 될 수 있는 한 줄여야하고, 이를 위해서 캐시를 사용하는 것은 항상 옳은 선택이라고 보는 관점이다.

모든 컴포넌트를 memo로 감싼다면 우리가 지불해야하는 비용은 렌더링될 컴포넌트가 캐싱되는 것이다. 리액트는 이전 렌더링 결과를 current DOM에 저장하고 있기 때문에 결국 우리가 지불해야 하는 비용은 props에 대한 얕은 비교뿐이다. props가 매우 크다면 이 비용이 크겠지만 아니라면 렌더링을 수행하는 것보다 싸지않을까?

memo했으면 렌더링이 진행되지 않았을 컴포넌트가 memo하지 않아서 렌더링될 때 내는 비용은 다음과 같다.

- 렌더링 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 위 두 가지가 모두 포함된 자식 컴포넌트의 실행
- 리액트의 WorkInProgress 트리와 current 트리의 비교

`useMemo, useCallback도 비슷한 관점에서 실보다 득이 훨씬 크기 때문에 가능한 한 모든 곳에 적용하도록 하자.`
