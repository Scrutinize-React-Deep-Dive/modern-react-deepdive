## 2.3 클래스형 컴포넌트와 함수형 컴포넌트

### 클래스형 컴포넌트

**constructor()**

컴포넌트 내부에 이 생성자 함수가 있다면, 컴포넌트가 초기화되는 시점에 호출

컴포넌트의 state 초기화 가능

`super()`를 통해 상속받은 상위 컴포넌트, 즉 `React.Component`의 생성자 함수를 먼저 호출해 필요한 상위 컴포넌트에 접근 가능

**props**

컴포넌트에 특정 속성을 전달하는 용도

**state**

클래스 컴포넌트 내부에서 관리하는 값

항상 객체여야 하며, 이 값에 변화가 있을 때마다 리렌더링 발생

**메서드**

렌더링 함수 내부에서 사용되는 함수이며, 보통 DOM에서 발생하는 이벤트와 함께 사용됨

이를 만드는 방식은 아래와 같이 크게 3가지로 나뉜다.

- constructor에서 this 바인드를 하는 방법

- 화살표 함수를 쓰는 방법

- 렌더링 함수 내부에서 함수를 새롭게 만들어 전달하는 방법

<br/>

### 생명주기 메서드

**생명주기 메서드가 실행되는 시점**

- **마운트(mount)**: 컴포넌트가 마운팅(생성)되는 시점

- **업데이트(update)**: 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점

- **언마운트(unmount)**: 컴포넌트가 더 이상 존재하지 않는 시점

<br/>

<p align="center">
  <img src="https://github.com/Scrutinize-React-Deep-Dive/modern-react-deepdive/assets/71490862/ce5bd1dc-10cb-41d4-a10e-5e02815627e9" alt="리액트 생명주기">
  React LifeCycle
</p>

**render()**

리액트 클래스형 컴포넌트의 유일한 필수 값으로 항상 쓰이며, 컴포너트가 UI를 렌더링하기 위해서 쓰인다. render() 함수는 항상 순수해야 하며, 부수 효과가 없어야 한다. 즉 항상 같은 결과물을 반환해야 한다.

**componentDidMount()**

컴포넌트가 마운트되고 즉시 실행되며 state값 변경이 가능하다.
ui 업데이트 전에 실행되어 사용자가 변경되는 것을 눈치챌 수 없다.

**componentDidUpdate()**

컴포넌트 업데이트가 일어난 이후 바로 실행되며, state나 props의 변화에 따라 DOM을 업데이트하는 등에 쓰인다.
하지만, state가 계속해서 호출될 수 있어 주의해야 한다.

**componentWillUnmount()**

컴포넌트가 언마운트되거나 더 이상사용되지 않기 직전에 호ㅜㄹ되며, 클린업 함수 호출하기 위한 최적의 위치이다. state업데이트는 불가능하다.

**shouldComponentUpdate()**

state나 props의 변경으로 리액트 컴포너트가 다시 리렌더링되는 것을 막고 싶다면 사용할 수 있다.
하지만, 이는 특정한 성능 최적화 상황에서만 고려하는 게 좋다.

**state getDrivedStateFormProps()**

render()를 호출하기 직전에 호출된다. 또한 static으로 선언되어 있어 this에 접근할 수 없다.

**getSnapShotBeforeUpdate()**

DOM이 업데이트되기 전에 호출된다.
렌더링 되기 전 윈도우 크기를 조절하거나 스크롤 위치를 조정하는 등의 작업 처리에 유용하다.

**getDerivedStateFromError()**

에러 상황에서 실행되는 메서드이며, error를 인수로 받는다.
이때 error는 하위 컴포넌트에서 발생한 에러를 말하며, 반드시 state값을 반환해야 한다.
하위 컴포넌트에서 에러가 발생했을 경우에 어떻게 자식 리액트 컴포넌트를 렌더링할지 결정하는 용도로 제공되는 메서드이기 때문에 반드시 미리 정의해 둔 state값을 반환해야 한다.
또한 렌더링 과정에서 호출되는 메서드이기 때문에 부수 효과를 발생시켜서는 안된다.
( 에러에 따른 상태 외에 모든 작업 )

**componentDidCatch()**

자식 컴포넌트에서 에러가 발생했을 때 실행되며, 에러를 `getDerivedStateFromError()` 에서 잡고, state를 결정한 이후에 실행된다.
두 개의 인수를 받는데, 첫 인수는 getDerivedStateFromError()에서 동일한 error, 또한 두번째 인수는 어떤 컴포넌트가 에러를 발생시켰는지 정보를 가지고 있는 info이다.

<br/>

### Component vs PureComponent

`Component`는 state가 업데이트되는 대로 렌더링 발생

`PureComponent`는 state 값에 대해 얕은 비교를 수행해 결과가 다를 때만 렌더링 수행

**모든 컴포넌트를 PureComponent로 선언하는 것이 좋을까?**

놉, PureComponent는 얕은 비교만 수행하기 때문에 state가 객체와 같이 복잡한 구조의 데이터 변경은 감지하지 못해서 제대로 작동하지 않는다.

또한 애플리케이션 대다수의 컴포넌트가 PureComponent로 구성되어 있다면, 오히려 성능에 역효과를 미칠 수도 있다. (무의미한 얕은 비교를 수행해서)

<br/>

### 클래스 컴포넌트의 한계

- 데이터의 흐름을 추적하기 어렵다.

- 애플리케이션 내부 로직의 재사용이 어렵다.

- 기능이 많아질수록 컴포넌트의 크기가 커진다.

- 클래스는 함수에 비해 상대적으로 어렵다.
