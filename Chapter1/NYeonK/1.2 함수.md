## 1.2 함수

### 함수를 정의하는 방법

: 함수 선언문, 함수 표현식, Function 생성자, 화살표 함수

**함수 표현식과 함수 선언문의 차이 => 호이스팅**

- 함수 선언문은 해당하는 함수의 전체 내용이 호이스팅된다. 따라서, 어디서든 호출 가능
- 함수 표현식은 함수를 변수에 할당하는 것인데, 이 변수 선언 부분만 호이스팅 되고 함수 할당은 호이스팅되지 않음. 따라서 함수 호출은 함수 할당 이후에만 가능

**화살표 함수의 특징**

- constructor를 사용할 수 없다 => 생성자 함수로 사용 불가
- arguments가 존재하지 않는다.
- 일반함수와 this 바인딩의 차이

화살표 함수 이전까지는 함수가 어떻게 호출되느냐에 따라 동적으로 결정.

만약 일반 함수로서 호출된다면, 그 내부의 this는 전역 객체를 가리킨다.

화살표 함수는 함수 자체의 바인딩을 가지지 않는다. 화살표 내부에서 this 바인딩을 참조하면, 상위 스코프의 this를 그대로 따르게 된다.

<br/>

### 함수를 사용하는 방법

**1) 즉시 실행 함수 (Immediately Invoked Function Expression, IIFE)**

함수를 정의하고, 그 순간 즉시 실행되는 함수. 다시 호출 X

```jsx
((a, b) => {
    return a + b
  },
)(5, 10) // 15
```

⇒ 이 특성을 활용하면, 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프를 운용할 수 있다. 함수의 선언과 실행이 바로 그 자리에서 끝나기 때문에 즉시 실행 함수 내부에 있는 값은 그 함수 내부가 아니고서는 접근이 불가능하기 때문이다.

⇒ 👀 재사용되지 않는 함수 어디에서 사용될까

es) useEffect → asyne/await → 데이터 패칭 1번만 사용할 때

```jsx
(async function () {
  const res = await (await fetch("")).json();
  alert(res);
})();
```

**2) 고차 함수 (Higher Order Function)**

자바스크립트의 함수가 일급 객체라는 특징을 활용하면, 함수를 인자로 받거나, 결과로 새로운 함수를 반환 시킬수 있다. 이런 역할을 하는 함수를 고차 함수라고 한다. ex) map, filter, reduce...

<br/>

### **함수 만들때 주의 사항**

- 함수의 부수 효과(side-effect)를 최대한 억제하라.
  - 함수의 부수 효과란 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것을 의미. 이러한 부수 효과가 없는 함수를 순수 함수라 한다.
  - 순수 함수는 언제 실행되든 항상 결과가 동일하기 때문에 예측 가능 하며 안정적이다.
  - React 관점에서 본다면, useEffect의 작동을 최소화하자. useEffect 사용은 피할 수 없지만, 최소한으로 줄임으로써 함수의 역할을 좁히고, 버그를 줄이며 컴포넌트의 안정성을 높일 수 있음
  - 예측 가능한 단위의 부수 효과가 작은 함수를 설계하면, 개발자와 이를 유지보수하는 또 다른 개발자에게 도움된다.
- 가능한 한 함수를 작게 만들어라.
  - 함수는 하나의 일을, 그 하나만 잘하면 된다. 그것이 함수의 원래 목적인 재사용성을 높일 수 있는 방법이다.
- 누구나 이해할 수 있는 이름을 붙여라
  - useEffect의 콜백 함수에 이름 붙여보자 → 부수 효과를 일으키는 함수가 많아질수록, 굳이 useEffect 코드를 유심히 살펴보지 않더라도 어떤 일과 작동을 하는지 알아채는 데 도움됨.
  ```jsx
  useEffect(fuction apiRequest() {
  	// ... do something
  }, []))
  ```

<br/>
