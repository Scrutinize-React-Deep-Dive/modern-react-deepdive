## 1.3 클래스

: 자바스크립트에서의 클래스란, **특정한 객체를 만들기 위한 일종의 템플릿과 같은 개념**. 즉, 특정한 형태의 객체를 반복적으로 만들기 위해 사용되는 것이 클래스이다.

이는 객체를 만드는 데 필요한 데이터나 이를 조작하는 코드를 추상화해 객체 생성을 더욱 편리하게 할 수 있다. 또한 자바스크립트 클래스로 하는 모든 것들은 함수로도 동일하게 표현 가능.

**constructor**

: 생성자로, 객체를 생성하는 데 사용하는 특수한 메서드이다. 단 하나만 존재 가능하며, 필요가 없다면 생략 가능.

**프로퍼티**

: 클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값을 의미

- #을 붙여서 private을 선언하는 방법이 ES2019에 추가됐고, TS를 활용하면 public, protected, private을 사용할 수 있다. JS에서는 기본적으로 모든 프로퍼니가 public이다.

**getter와 setter**

: getter는 클래스에서 무언가 값을 가져올 때 사용된다. getter를 사용하기 위해서는 get을 붙여야 함.

: setter란 클래스 필드에 값을 할당할 때 사용한다. 마찬가지로 set 키워드 먼저 선언 필요

**인스턴스 메서드**

: 클래스 내부에서 선언한 메서드. 이는 실제로 자바스크립트의 prototype에 선언되므로 프로토타입 메서드라고 불리기도 한다.

직접 객체에 선언하지 않았음에도 프로토타입에 있는 메서드를 찾아서 실행을 도와주는 것을 바로 **프로토타입 체이닝**이라고 한다. 모든 객체는 프로토타입을 가지고 있는데, 특성 속성을 찾을 때 자기 자신부터 시작해서 이 프로토타입을 타고 최상위 객체인 Object까지 훑는다.

```jsx
class Car {
  constructor(name) {
    this.name = name;
  }

  //인스턴스 메서드 정의
  hello() {
    console.log(`안녕하세요, ${this.name}입니다.`);
  }
}

const myCar = new Car("자동차");
myCar.hello(); // 안녕하세요, 자동차입니다.

Object.getPrototypeOf(myCar); // {constructor: f, hello: f}
```

프로토타입과 프로토타입 체이닝 덕분에, 생성한 객체에서도 직접 선언하지 않은 hello() 메서드를 호출할 수 있고, 이 메서드 내부에서 this도 접근해 상요할 수 있게 된다.

**정적 메서드**

: 클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드이다.

```jsx
class Car() {
	static hello() {
		console.log("안녕하세요")
	}
)

const myCar = new Car()

myCar.hello() // TypeError: myCar.hello is not a function
Car.hello() // 안녕하세요
```

정적 메서드 내부의 this는 클래스로 생성된 인스턴스가 아닌, 클래스 자신을 가리키기 때문에 다른 메서드에서 일반적으로 사용하는 this를 사용할 수 없다.

this 접근은 할 수 없지만, 인스턴스를 생성하지 않아도 사용할 수 있다는 점, 그리고 생성하지 않아도 접근할 수 있기 때문에 객체를 생성하지 않더라도 여러 곳에서 재사용이 가능하다는 장점이 있다.

**상속**

: extends는 기존 클래스를 상속받아서 자식 클래스에게 이 상속받은 클래스를 기반으로 확장하는 개념이라고 볼 수 있다.

<aside>
💡 클래스는 ES6에서 나온 개념으로, ES6 이전에는 프로토타입을 활용해 클래스의 작동 방식을 동일하게 구현할 수 있었다. 클래스가 작동하는 방식은 자바스크립트의 프로토타입을 활용하는 것이라고 볼 수 있다.

</aside>

<br/>
