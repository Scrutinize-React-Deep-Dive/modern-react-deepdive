## 1.1 자바스크립트의 동등 비교

### 자바스크립트의 데이터 타입

**원시 타입(primitive type)**

- boolean
- null
- undefined
- number
- string
- symbol
- bigint

<br/>

**객체 타입(object/reference type)**

- object

<br/>
undefined: 선언됐지만 할당되지 않은 값<br/>
null: 명시적으로 비어 있음을 나타내는 값

⇒ null은 다른 원시값과 다르게, typeof로 확인했을 때, `object` 라는 결과가 반환된다. 이는 초창기 자바스크립트가 값을 표현하는 방식 때문에 발생한 문제로, 이후 변경하고자 했으나 호환성 문제로 실패!

**falsy 한 값**

- false
- 0, -0, 0n, 0x0n
- NaN
- '', "", ``
- null
- undefined

여기서 문자열이 falsy하기 위해서는 반드시 공백이 없는 빈 문자열이어야 한다.

객체와 배열은 내부에 값이 존재하는지 여부와 상관없이 truthy로 취급된다.

---

### **원시 타입 vs 객체 타입**

원시 타입과 객체 타입의 가장 큰 차이점은 **값을 저장하는 방식**이다.

**원시 타입은 값을 직접 저장하지만, 객체 타입은 메모리 상에서 참조됩니다. (변수에는 객체의 위치가 저장됨)**

원시 타입은 값이 불변 형태로 저장되며, 이 값은 변수 할당 시점에 메모리 영역을 차지하고 저장된다. 변경하려면 변수에 재할당해야한다. 또한, 속성이나 메서드가 없다.

동등 비교시에 원시 타입은 값 자체를 비교한다.

**객체는 프로퍼티를 삭제, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장**되며, 값을 복사할 때에도 값이 아닌 참조를 전달.

객체는 값이 같더라도 서로 다른 참조를 갖기 때문에 동등비교시 false

### **📌 Object.is**

: 두 개의 인수를 받으며, 이 인수 두 개가 동일한지 확인하고 반환하는 메서드이다.

==는 강제 형변환 진행, ===는 형변환 작업 x, 타입 비교

Object.is는 이러한 === 보다 더 개발자가 기대하는 방식으로 더 정확히 비교

ex)

```jsx
-0 === +0; // true
Object.is(-0, +0); // false

Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true

NaN === 0 / 0; // false
Object.is(NaN, 0 / 0); // true
```

=== 보다 더 정확해진 문법이지만, 객체 비교에 있어서는 ===와 동일하게 동작함.

**Object.is 개념이 중요한 이유** => **리액트에서 사용하는 동등 비교의 방법이기 때문.**

리액트에서는 Object.js로 먼저 비교를 수행하고, 이후 Object.js에서는 수행하지 못하는 비교, 즉 객체 간의 얕은 비교를 한 번 더 수행한다.

- _객체 간의 얕은 비교란 객체의 첫 번째 깊이에 존재하는 값만 비교한다는 것_

**왜 얕은 비교만 할까?**

**1. 성능 향상**

깊은 비교는 비용이 많이 들 수 있다. 모든 속성을 재귀적으로 비교하는 것은 성능에 부담이 된다.

**2. 일반적인 사용 사례**

React에서 사용하는 props의 대부분은 원시값이거나 얕은 객체일 가능성이 높다. React에서는 props에서 꺼내온 값을 기준으로 렌더링을 수행하기 때문에 일반적인 케이스에서는 얕은 비교만으로 충분.

```jsx
type DeeperProps = {
  counter: {
    counter: number,
  },
};
```

⇒ 이와 같이 props가 깊어지는 경우, 즉 한 객체 안에 또 다른 객체가 있을 경우 React.memo는 컴포넌트에 실제 변경된 값이 없음에도 불구하고 메모이제이션된 컴포넌트를 반환하지 못한다.

<br/>
